import cv2
import numpy as np
import zipfile
import os
from multiprocessing import Pool

# Función para cargar imágenes desde un archivo ZIP
def cargar_imagenes_zip(zip_path):
    imagenes = []
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        for archivo in zip_ref.namelist():
            if archivo.endswith(".jpg") or archivo.endswith(".png"):
                with zip_ref.open(archivo) as file:
                    img_array = np.frombuffer(file.read(), np.uint8)
                    img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)  # Cargar en color
                    imagenes.append((archivo, img))
    return imagenes

# Función para aplicar transformaciones básicas
def aplicar_transformaciones(img):
    # Reducción de tamaño
    img = cv2.resize(img, (img.shape[1] // 2, img.shape[0] // 2))
    
    # Normalización
    img = cv2.normalize(img, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX)
    
    # Filtrado Gaussiano
    img = cv2.GaussianBlur(img, (5, 5), 0)
    
    return img

# Función para aplicar operaciones adicionales (segmentación y convolución)
def aplicar_operaciones(img):
    # Segmentación simple (umbralización adaptativa)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                cv2.THRESH_BINARY, 11, 2)
    
    # Convolución - Detección de bordes
    img = cv2.Canny(img, 50, 150)
    
    return img

# Función para realizar el template matching y clasificar la imagen
def template_matching_clasificacion(args):
    img_name, img, plantillas, umbral, directorios_clasificacion = args
    max_val_global = 0
    mejor_plantilla = None
    
    # Aplicar transformaciones y operaciones a la imagen
    img = aplicar_transformaciones(img)
    img = aplicar_operaciones(img)
    
    for nombre_clase, plantilla in plantillas.items():
        # Aplicar transformaciones y operaciones a la plantilla
        plantilla = aplicar_transformaciones(plantilla)
        plantilla = aplicar_operaciones(plantilla)
        
        metodo = cv2.TM_CCOEFF_NORMED
        res = cv2.matchTemplate(img, plantilla, metodo)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
        if max_val > max_val_global:
            max_val_global = max_val
            mejor_plantilla = nombre_clase
    
    if max_val_global > umbral:
        resultado_path = os.path.join(directorios_clasificacion[mejor_plantilla], os.path.basename(img_name))
        cv2.imwrite(resultado_path, img)
    else:
        # Si no coincide con ninguna plantilla, guardar en una carpeta de "sin coincidencia"
        resultado_path = os.path.join(directorios_clasificacion['no_match'], os.path.basename(img_name))
        cv2.imwrite(resultado_path, img)

# Rutas y directorios
zip_path = 'imagenes.zip'
directorio_resultados = 'resultados'
umbral = 0.8

# Crear directorios de clasificación si no existen
directorios_clasificacion = {
    'box': os.path.join(directorio_resultados, 'box'),
    'circ': os.path.join(directorio_resultados, 'circ'),
    'cross': os.path.join(directorio_resultados, 'cross'),
    'no_match': os.path.join(directorio_resultados, 'no_match')
}

for directorio in directorios_clasificacion.values():
    os.makedirs(directorio, exist_ok=True)

# Cargar plantillas
plantillas = {
    'box': cv2.imread('box_template.jpg', cv2.IMREAD_COLOR),
    'circ': cv2.imread('circ_template.jpg', cv2.IMREAD_COLOR),
    'cross': cv2.imread('cross_template.jpg', cv2.IMREAD_COLOR)
}

# Cargar imágenes desde el archivo ZIP
imagenes = cargar_imagenes_zip(zip_path)

# Preparar los argumentos para el multiprocesamiento
args = [(img_name, img, plantillas, umbral, directorios_clasificacion) for img_name, img in imagenes]

# Procesar las imágenes usando multiprocesamiento
with Pool() as pool:
    pool.map(template_matching_clasificacion, args)
